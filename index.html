<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Review Sentiment & Noun Analyzer</title>
    <style>
        body { font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }
        .container { background: #f5f5f5; padding: 20px; border-radius: 10px; }
        input, button { padding: 10px; margin: 5px; border: 1px solid #ddd; border-radius: 5px; }
        button { background: #007bff; color: white; cursor: pointer; }
        button:hover { background: #0056b3; }
        button:disabled { background: #6c757d; cursor: not-allowed; }
        .review-box { background: white; padding: 15px; border: 1px solid #ddd; margin: 10px 0; }
        .result { margin: 10px 0; padding: 10px; background: #e9ecef; border-radius: 5px; }
        .noun-highlight { background-color: yellow; font-weight: bold; }
        .status { color: #666; font-style: italic; }
        .error { color: #dc3545; }
        .success { color: #28a745; }
    </style>
    <!-- Подключаем библиотеки -->
    <script src="https://unpkg.com/compromise@14.0.0/builds/compromise.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
</head>
<body>
    <div class="container">
        <h1>Review Sentiment & Noun Analyzer</h1>
        
        <!-- Hugging Face API Setup -->
        <div class="api-setup">
            <h3>Hugging Face API Setup</h3>
            <input type="password" id="apiToken" placeholder="Enter your Hugging Face API Token" style="width: 300px;" 
                   value="ht_DCEffkDddrgfZWJGPxPJwNhigkuBafHE">
            <p><small>Your token is stored only in your browser and is never sent to our servers.</small></p>
        </div>

        <!-- Analysis Controls -->
        <div class="controls">
            <button onclick="loadRandomReview()">Load Random Review</button>
            <button onclick="analyzeSentiment()">Analyze Sentiment</button>
            <button onclick="countNouns()">Count Nouns</button>
        </div>

        <!-- Display Areas -->
        <div class="review-box">
            <h3>Selected Review:</h3>
            <div id="reviewText">Click "Load Random Review" to load a review.</div>
        </div>

        <div class="result">
            <h3>Analysis Results:</h3>
            <div id="sentimentResult">Sentiment will appear here</div>
            <div id="nounResult">Noun analysis will appear here</div>
        </div>

        <!-- Status -->
        <div class="status" id="status">Ready to load reviews from TSV file</div>

        <!-- Instructions -->
        <div class="instructions">
            <h3>How to get a Hugging Face API Token:</h3>
            <ol>
                <li>Go to huggingface.co and create a free account</li>
                <li>Navigate to your profile settings and access tokens section</li>
                <li>Generate a new token with read permissions</li>
                <li>Copy the token and paste it in the field above</li>
            </ol>
        </div>
    </div>

    <script>
        let currentReview = '';
        let reviews = [];
        let reviewsLoaded = false;

        // Загружаем отзывы из TSV файла
        async function loadReviewsFromTSV() {
            const statusEl = document.getElementById('status');
            statusEl.textContent = 'Loading reviews from TSV file...';
            statusEl.className = 'status';
            
            try {
                const response = await fetch('reviews_test.tsv');
                if (!response.ok) {
                    throw new Error(`Failed to load TSV file: ${response.status}`);
                }
                
                const tsvData = await response.text();
                
                // Парсим TSV с помощью PapaParse
                const results = Papa.parse(tsvData, {
                    header: true,
                    delimiter: '\t',
                    skipEmptyLines: true
                });
                
                if (results.errors.length > 0) {
                    console.warn('Parse errors:', results.errors);
                }
                
                // Извлекаем тексты отзывов из колонки "text"
                reviews = results.data
                    .filter(row => row.text && row.text.trim() !== '')
                    .map(row => row.text.trim());
                
                if (reviews.length === 0) {
                    throw new Error('No reviews found in TSV file. Please check the "text" column.');
                }
                
                reviewsLoaded = true;
                statusEl.textContent = `Successfully loaded ${reviews.length} reviews from TSV file`;
                statusEl.className = 'status success';
                console.log('Loaded reviews:', reviews);
                
            } catch (error) {
                console.error('Error loading TSV:', error);
                statusEl.textContent = `Error: ${error.message}. Using fallback reviews.`;
                statusEl.className = 'status error';
                
                // Fallback на встроенные отзывы если TSV не загрузился
                reviews = [
                    "McVitie's digestive biscuits are great - not nearly as sweet as competitors. Biggest problem is how many are broken by the time they get to you.",
                    "I love lemon grass tea! I love this soup! Going to double my order on the next one I make, this one is so good.",
                    "The product quality is excellent but the delivery service was terrible. The package arrived damaged and items were missing."
                ];
                reviewsLoaded = true;
            }
        }

        // Загружаем случайный отзыв
        function loadRandomReview() {
            if (!reviewsLoaded) {
                alert('Reviews are still loading. Please wait...');
                return;
            }
            
            if (reviews.length === 0) {
                alert('No reviews available. Please check the TSV file.');
                return;
            }
            
            const randomIndex = Math.floor(Math.random() * reviews.length);
            currentReview = reviews[randomIndex];
            document.getElementById('reviewText').textContent = currentReview;
            document.getElementById('sentimentResult').textContent = 'Sentiment will appear here';
            document.getElementById('nounResult').textContent = 'Noun analysis will appear here';
            
            document.getElementById('status').textContent = `Loaded review ${randomIndex + 1} of ${reviews.length}`;
            document.getElementById('status').className = 'status success';
        }

        // Анализ тональности - ИСПРАВЛЕННАЯ ВЕРСИЯ
        async function analyzeSentiment() {
            const apiToken = document.getElementById('apiToken').value;
            if (!apiToken) {
                alert('Please enter your Hugging Face API Token');
                return;
            }

            if (!currentReview) {
                alert('Please load a review first');
                return;
            }

            const statusEl = document.getElementById('status');
            const resultEl = document.getElementById('sentimentResult');
            
            statusEl.textContent = 'Analyzing sentiment...';
            statusEl.className = 'status';
            resultEl.textContent = 'Processing...';

            try {
                // ИСПРАВЛЕНИЕ: Используем ту же модель, что работала в DeepSeek
                const response = await fetch(
                    "https://api-inference.huggingface.co/models/siebert/sentiment-roberta-large-english",
                    {
                        headers: { 
                            Authorization: `Bearer ${apiToken}`,
                            "Content-Type": "application/json"
                        },
                        method: "POST",
                        body: JSON.stringify({ 
                            inputs: currentReview 
                        }),
                    }
                );
                
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`API error: ${response.status} - ${errorText}`);
                }
                
                const result = await response.json();
                console.log('API Response:', result);
                
                if (result.error) {
                    throw new Error(`Model error: ${result.error}`);
                }

                // Обрабатываем результат для модели siebert/sentiment-roberta-large-english
                // Эта модель возвращает массив с одним объектом, содержащим label и score
                if (Array.isArray(result) && result.length > 0) {
                    const sentiment = result[0];
                    const label = sentiment.label || 'UNKNOWN';
                    const score = sentiment.score || 0;
                    
                    resultEl.innerHTML = 
                        `<strong>Label:</strong> ${label} <br>
                         <strong>Confidence:</strong> ${(score * 100).toFixed(2)}% <br>
                         <strong>Model:</strong> siebert/sentiment-roberta-large-english`;
                    
                    statusEl.textContent = 'Sentiment analysis complete';
                    statusEl.className = 'status success';
                } else {
                    throw new Error('Unexpected response format from API');
                }

            } catch (error) {
                console.error('Sentiment analysis error:', error);
                resultEl.textContent = `Error: ${error.message}`;
                resultEl.className = 'error';
                statusEl.textContent = 'Analysis failed';
                statusEl.className = 'status error';
            }
        }

        // Подсчет существительных
        function countNouns() {
            if (!currentReview) {
                alert('Please load a review first');
                return;
            }

            const statusEl = document.getElementById('status');
            const resultEl = document.getElementById('nounResult');
            
            statusEl.textContent = 'Counting nouns...';
            statusEl.className = 'status';

            try {
                // Используем Compromise.js для NLP
                const doc = window.nlp(currentReview);
                const nouns = doc.nouns().out('array');
                
                // Убираем дубликаты и пустые строки
                const uniqueNouns = [...new Set(nouns.filter(noun => noun.trim() !== ''))];
                
                // Подсвечиваем существительные в тексте
                let highlightedText = currentReview;
                uniqueNouns.forEach(noun => {
                    const escapedNoun = noun.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                    const regex = new RegExp(`\\b${escapedNoun}\\b`, 'gi');
                    highlightedText = highlightedText.replace(regex, `<span class="noun-highlight">${noun}</span>`);
                });

                document.getElementById('reviewText').innerHTML = highlightedText;
                resultEl.innerHTML = 
                    `<strong>Total Nouns Found:</strong> ${uniqueNouns.length} <br>
                     <strong>Nouns List:</strong> ${uniqueNouns.join(', ')} <br>
                     <small>Nouns are highlighted in yellow above</small>`;
                
                statusEl.textContent = `Found ${uniqueNouns.length} unique nouns`;
                statusEl.className = 'status success';

            } catch (error) {
                console.error('Noun counting error:', error);
                resultEl.textContent = `Error counting nouns: ${error.message}`;
                resultEl.className = 'error';
                statusEl.textContent = 'Noun counting failed';
                statusEl.className = 'status error';
            }
        }

        // Инициализация - загружаем отзывы при загрузке страницы
        window.onload = loadReviewsFromTSV;
    </script>
</body>
</html>
